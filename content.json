{"meta":{"title":"Tango","subtitle":"探戈","description":"花有重开日，人无再少年","author":"FaderW","url":"www.google.com"},"pages":[{"title":"about","date":"2018-08-09T18:05:14.000Z","updated":"2019-07-15T03:27:34.243Z","comments":true,"path":"about/index.html","permalink":"www.google.com/about/index.html","excerpt":"","text":"个人简介 nickname:FaderW industry: Java programmers email: wyx19950516@163.com"},{"title":"分类","date":"2017-07-21T09:00:14.000Z","updated":"2019-07-15T03:27:34.243Z","comments":true,"path":"categories/index.html","permalink":"www.google.com/categories/index.html","excerpt":"","text":""},{"title":"history","date":"2018-08-09T17:52:54.000Z","updated":"2019-07-15T03:27:34.243Z","comments":true,"path":"history/index.html","permalink":"www.google.com/history/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-29T15:45:38.000Z","updated":"2019-07-15T03:27:34.243Z","comments":true,"path":"tags/index.html","permalink":"www.google.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"同步工具类","slug":"同步工具类","date":"2019-01-18T16:32:41.000Z","updated":"2019-07-15T03:27:34.243Z","comments":true,"path":"2019/01/18/同步工具类/","link":"","permalink":"www.google.com/2019/01/18/同步工具类/","excerpt":"","text":"闭锁CountDownLatch 闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。 CountDownLatch是一种灵活的闭锁，它可以始一个或多个线程等待一组事件的发生。CountDownLatch内部包含一个计数器，初始化时传入一个正数，表示当前需要等待的事件数量。每次完成一个事件，调用countDown递减计数器。await方法阻塞到计数器变为0。 示例：CountDownLatch countDownLatch = new CountDownLatch(3); for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; &#123; try &#123; Thread.sleep(10L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"child thread end!\"); countDownLatch.countDown(); &#125;).start(); &#125; countDownLatch.await(); System.out.println(\"main thread end!\"); 创建一个计数器为3的闭锁，主线程等待三个子线程执行完才能结束。 结果：child thread end!child thread end!child thread end!main thread end! 信号量Semaphore 计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。Semaphore中管理着一组虚拟的许可（permit）。许可数量通过构造函数传入。每次执行操作前需要阻塞获取许可，执行完释放许可。可用来实现某种资源池或者对容器施加边界。 示例：利用信号量实现一个简单的阻塞容器public class BoundHashSet&lt;T&gt; &#123; private final Set&lt;T&gt; set; private final Semaphore semaphore; public BoundHashSet(int bound) &#123; this.semaphore = new Semaphore(bound); this.set = Collections.synchronizedSet(new HashSet&lt;&gt;()); &#125; public boolean add(T t) throws InterruptedException &#123; semaphore.acquire(); boolean wasAdd = set.add(t); if (wasAdd) &#123; return true; &#125; else &#123; semaphore.release(); return false; &#125; &#125; public boolean remove(T t) &#123; if (set.remove(t)) &#123; semaphore.release(); return true; &#125; return false; &#125;&#125; 补充一种特殊的的信号量——二值信号量，即许可数量为1。具有不可重入的加锁语义。 栅栏CycleBarrier 栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。线程到达栅栏是调用await方法，这个方法将阻塞到直到所有线程都到达该位置。如果await调用超时，或者调用线程被中断，那么栅栏被认为是打破了，所有调用await的线程将抛出BrokenBarrierException。 初始化栅栏时，同时可传入一个事件，这里是runnable,在成功通过栅栏时会执行它。 示例：public static class Draw implements Runnable&#123; private String value; private CyclicBarrier barrier; public Draw() &#123; &#125; public Draw(CyclicBarrier barrier) &#123; this.barrier = barrier; &#125; public void setBarrier(CyclicBarrier barrier) &#123; this.barrier = barrier; &#125; public String getValue() &#123; return this.value; &#125; @Override public void run() &#123; try &#123; value = RandomStringUtils.randomAlphabetic(4); barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService pool = Executors.newFixedThreadPool(8); List&lt;Draw&gt; drawList = Lists.newArrayList(); CyclicBarrier barrier = new CyclicBarrier(4, () -&gt; &#123; StringBuilder stringBuilder = new StringBuilder(); drawList.forEach(draw -&gt; stringBuilder.append(draw.getValue())); System.out.println(stringBuilder.toString()); &#125; ); for (int i = 0; i &lt; 4; i++) &#123; drawList.add(new Draw(barrier)); &#125; drawList.forEach(draw -&gt; pool.submit(draw)); &#125; 分四个线程绘制一个16位的英文串。每个线程分别绘制4位，当四个线程都到达栅栏位置，拼接得到16位的整串。（注意这里的只是使用示例，改程序没有实际意义） 运行结果：iQuNmojnCyUjCPAe","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"www.google.com/tags/concurrent/"}]},{"title":"post请求流的使用","slug":"post请求流的使用","date":"2018-09-21T14:01:50.000Z","updated":"2019-07-15T03:27:34.243Z","comments":true,"path":"2018/09/21/post请求流的使用/","link":"","permalink":"www.google.com/2018/09/21/post请求流的使用/","excerpt":"","text":"post方法 request.getInputStream()为空解惑 前言在SpringMVC web应用中，对于一个rest接口，获取请求参数我们一般使用@requestParam、@requestBody等注解 。对于表单类型的请求参数，有一下几种获取方式 @requestParam注解方式 request.getParameter(String name) request.getInputStream() 前两种方式其实是一种方式，@requestParam底层就是利用request.getParameter的原理。这两种方式有一个弊端就是只能一个个获取，而且必须知道对方传过来的参数的key值，如果想要一次性获取，可以使用request.getInputStream方法获取一个inputStream对象，然后读取流里面的数据。 //获取到的数据格式key=value以‘&amp;’分隔的形式age=20&amp;name=faderw 问题但在实际过程中，我们会发现通过request.getInputStream()方式获取的数据为空。 根据Servlet规范，如果同时满足下列条件，则请求体(Entity)中的表单数据，将被填充到request的parameter集合中（request.getParameter系列方法可以读取相关数据） 这是一个HTTP/HTTPS请求 请求方法是POST（querystring无论是否POST都将被设置到parameter中） 请求的类型（Content-Type头）是application/x-www-form-urlencoded Servlet调用了getParameter系列方法 这里的表单数据已经被填充到parameterMap中，不能再通过getInputStream获取。 如何解决这个问题呢。 实现在javax.servlet.http包下面有一个装饰器类HttpServletRequestWrapper，利用这个装饰器类，我们可以重新包装一个HttpServletRequest对象。 public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest &#123; 定义一个装饰器继承HttpServletRequestWrapper,streamBody字节变量用来保存读取的数据，以便于多次读取。 public class InputStreamHttpServletRequestWrapper extends HttpServletRequestWrapper&#123; private final byte[] streamBody; private static final int BUFFER_SIZE = 4096; public InputStreamHttpServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); byte[] bytes = inputStream2Byte(request.getInputStream()); if (bytes.length == 0 &amp;&amp; RequestMethod.POST.name().equals(request.getMethod())) &#123; //从ParameterMap获取参数，并保存以便多次获取 bytes = request.getParameterMap().entrySet().stream() .map(entry -&gt; &#123; String result; String[] value = entry.getValue(); if (value != null &amp;&amp; value.length &gt; 1) &#123; result = Arrays.stream(value).map(s -&gt; entry.getKey() + \"=\" + s) .collect(Collectors.joining(\"&amp;\")); &#125; else &#123; result = entry.getKey() + \"=\" + value[0]; &#125; return result; &#125;).collect(Collectors.joining(\"&amp;\")).getBytes(); &#125; streamBody = bytes; &#125; private byte[] inputStream2Byte(InputStream inputStream) throws IOException &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] bytes = new byte[BUFFER_SIZE]; int length; while ((length = inputStream.read(bytes, 0, BUFFER_SIZE)) != -1) &#123; outputStream.write(bytes, 0, length); &#125; return outputStream.toByteArray(); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; ByteArrayInputStream inputStream = new ByteArrayInputStream(streamBody); return new ServletInputStream() &#123; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener listener) &#123; &#125; @Override public int read() throws IOException &#123; return inputStream.read(); &#125; &#125;; &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125;&#125; 声明一个带有HttpServletRequest入参的构造器，从该参数对象的流中解析数据，如果没有则继续从parameterMap中获取，然后以key=value&amp;key=value形式拼接。用streamBody接收。然后我们重写getInputStream方法，以后每次调用getInputStream方法，其实是重新利用streamBody重新new一个流，所以可以多次读取。 有了装饰器后，我们就要装饰目标对象。我们都知道SpringMVC的一次请求会被一个个过滤器层层调用，也就是我们常说的责任链模式。利用Filter我们就可以在某个特定的位置装饰HttpServletRequest对象。 public class InputStreamWrapperFilter extends OncePerRequestFilter&#123; @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; ServletRequest servletRequest = new InputStreamHttpServletRequestWrapper(httpServletRequest); filterChain.doFilter(servletRequest, httpServletResponse); &#125;&#125; OncePerRequestFilter这个过滤器能够保证一次请求只经过一次过滤器，所以我们直接继承该类就行了。 @Bean@Order(1)public FilterRegistrationBean inputStreamWrapperFilterRegistration() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new InputStreamWrapperFilter()); registrationBean.setName(\"inputStreamWrapperFilter\"); registrationBean.addUrlPatterns(\"/*\"); return registrationBean;&#125; 然后注册该过滤器，设置优先级为1。Spring Boot 会按照order值的大小，从小到大的顺序来依次过滤。 测试我们写一个简单的rest接口测试下 @PostMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)public Object inputStreamTest(HttpServletRequest request) throws Exception &#123; String bs = IOUtils.toString(request.getInputStream(), \"UTF-8\"); Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(1); map.put(\"data\", bs); return map;&#125; curl命令 curl -X POST \\ http://127.0.0.1:9003/home \\ -H 'Cache-Control: no-cache' \\ -H 'Content-Type: application/x-www-form-urlencoded' \\ -H 'Postman-Token: bb6e680c-5142-4d27-b930-6efb118a505a' \\ -d 'age=20&amp;name=wangyuxin' 结果 &#123; \"data\": \"age=20&amp;name=wangyuxin\"&#125;","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.google.com/tags/SpringBoot/"}]},{"title":"Venus","slug":"Venus","date":"2018-08-25T21:35:39.000Z","updated":"2019-07-15T03:27:34.227Z","comments":true,"path":"2018/08/25/Venus/","link":"","permalink":"www.google.com/2018/08/25/Venus/","excerpt":"","text":"轻量级爬虫框架Venus核心组件 Downloader(网页下载器) Spider(爬虫处理器) Scheduler(调度器) Parser(网页解析器) Pipline(数据处理器) Engine(流转引擎) 具体介绍Downloader网页下载器，顾名思义，就是从网络上下载数据，也就是爬虫的根本事件。给定一个或一组url,进行http请求，获取我们想要的数据（json、html、xml等）。而编写http请求的过程往往是重复的，所以应当进行封装以通用。 public class Downloader implements Runnable&#123; private final Scheduler Scheduler; private final Request request; public Downloader(Scheduler scheduler, Request request) &#123; this.Scheduler = scheduler; this.request = request; &#125; @Override public void run() &#123; log.info(\"start request url &#123;&#125;\", request.getUrl()); HttpRequest httpRequest = null; if (\"get\".equalsIgnoreCase(request.getMethod())) &#123; httpRequest = HttpRequest.get(request.getUrl()); &#125; else if (\"post\".equalsIgnoreCase(request.getMethod())) &#123; httpRequest = HttpRequest.post(request.getUrl()); &#125; else &#123; log.error(\"method &#123;&#125; 无效\", request.getMethod()); &#125; InputStream inputStream = httpRequest.contentType(request.contentType()) .headers(request.headers()).connectTimeout(request.getSpider().getConfig().timeout()) .readTimeout(request.getSpider().getConfig().timeout()).stream(); log.info(\"download has finsihed url &#123;&#125;\", request.getUrl()); Response response = new Response(request, inputStream); Scheduler.addResponse(response); &#125;&#125; 一个Downloader就是一个线程,Request对象封装了请求的信息，包括url、header等，请求完后，获取一个包含了返回数据的流，这里不作处理，直接构造一个response对象，然后压入到Scheduler（调取器）的返回队列中去。交给后续的爬虫处理器以及解析器来处理。 Scheduler调取器，就是调度请求与返回的，在解析器与下载器之间进行流转，解析器解析新的url加入请求队列中，调度器再生成新的下载器进行下载。 private BlockingQueue&lt;Request&gt; pending = Queues.newLinkedBlockingQueue();private BlockingQueue&lt;Response&gt; processed = Queues.newLinkedBlockingQueue(); Scheduler中有两个队列，待爬取的Request和已爬取的Response。Scheduler提供入队和出队操作，供其他组件进行调用。 Spider爬虫处理器，用于对爬取的数据进行处理，比如说入库、写文件等。 public abstract class Spider &#123; protected Config config; protected String name; protected List&lt;String&gt; startUrls = Lists.newArrayList(); protected List&lt;Request&gt; requests = Lists.newArrayList(); protected List&lt;Pipeline&gt; pipelines = Lists.newArrayList(); public void setConfig(Config config) &#123; this.config = config; &#125; public Config getConfig() &#123; return this.config; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public List&lt;Pipeline&gt; getPipelines() &#123; return this.pipelines; &#125; public void setPipelines(List&lt;Pipeline&gt; pipelines) &#123; this.pipelines = pipelines; &#125; public Spider() &#123; &#125; public Spider(String name) &#123; this.name = name; EventManager.registerEvent(EventManager.VenusEvent.SPIDER_STARTED, this::onStart); &#125; public List&lt;String&gt; getStartUrls() &#123; return this.startUrls; &#125; public Spider startUrls(String... urls) &#123; this.startUrls.addAll(Arrays.asList(urls)); return this; &#125; public List&lt;Request&gt; getRequests() &#123; return this.requests; &#125; /** * 爬虫启动前执行 */ public abstract void onStart(Config config); protected &lt;T&gt; Spider addPipline(Pipeline&lt;T&gt; pipeline) &#123; this.pipelines.add(pipeline); return this; &#125; /** * 构建一个request */ public &lt;T&gt; Request&lt;T&gt; makeRequest(String url) &#123; return makeRequest(url, this::parse); &#125; public &lt;T&gt; Request&lt;T&gt; makeRequest(String url, Parser&lt;T&gt; parser) &#123; return new Request&lt;&gt;(this, url, parser); &#125; /** * 解析DOM * 子类需要实现此方法 */ protected abstract &lt;T&gt; Result&lt;T&gt; parse(Response response); protected void resetRequest(Consumer&lt;Request&gt; consumer) &#123; this.resetRequest(this.requests, consumer); &#125; protected void resetRequest(List&lt;Request&gt; requests, Consumer&lt;Request&gt; consumer) &#123; requests.forEach(consumer::accept); &#125;&#125; param-startUrls 抽象类Spider维护了一个url集合，用于接受爬虫原始的url，进一步封装成request对象 method-parse 抽象方法，子类实现该方法定义自己的解析操作 param-pipeline 管道集合，进行数据处理的类，类似管道 Engine整个爬虫流程的核心控制器，流转引擎 public class VenusEngine &#123; private List&lt;Spider&gt; spiders; private Config config; private Scheduler scheduler; private ExecutorService executorService; private boolean isRunning; public VenusEngine(Venus venus) &#123; this.spiders = venus.spiders; this.config = venus.config; this.scheduler = new Scheduler(); this.executorService = new ThreadPoolExecutor(config.parallelThreads(), config.parallelThreads(), 60L, TimeUnit.MILLISECONDS, config.queueSize() == 0 ? new SynchronousQueue&lt;&gt;() : (config.queueSize() &lt; 0 ? new LinkedBlockingQueue&lt;&gt;() : new LinkedBlockingQueue&lt;&gt;(config.queueSize())), new ThreadFactoryBuilder().setNameFormat(\"task-thread-%d\").build()); &#125; public void start() &#123; if (isRunning) &#123; throw new RuntimeException(\"Venus 已经启动\"); &#125; isRunning = true; log.info(\"全局启动事件\"); EventManager.fireEvent(VenusEvent.GLOBAL_STARTED, this.config); spiders.forEach(spider -&gt; &#123; // 使用克隆为每个spider对象设置一个config属性 Config config = this.config.clone(); spider.setConfig(config); List&lt;Request&gt; requests = spider.getStartUrls().stream() .map(spider::makeRequest).collect(Collectors.toList()); spider.getRequests().addAll(requests); scheduler.addRequest(requests); EventManager.fireEvent(VenusEvent.SPIDER_STARTED, this.config); &#125;); // 开启一个线程来不断扫描是否有带爬取的Request Thread downloadThread = new Thread(() -&gt; &#123; while (isRunning) &#123; if (!scheduler.hasRequest()) &#123; VenusUtils.sleep(100); continue; &#125; Request request = scheduler.nextRequest(); executorService.submit(new Downloader(scheduler, request)); VenusUtils.sleep(request.getSpider().getConfig().Delay()); &#125; &#125;); downloadThread.setDaemon(true); downloadThread.setName(\"download-thread\"); downloadThread.start(); //消费 this.complete(); &#125; private void complete() &#123; while (isRunning) &#123; if (!scheduler.hasResponse()) &#123; VenusUtils.sleep(100); continue; &#125; Response response = scheduler.nextResponse(); Parser parser = response.getRequest().getParser(); if (null != parser) &#123; Result&lt;?&gt; result = parser.parse(response); List&lt;Request&gt; requests = result.getRequests(); if (!VenusUtils.isEmpty(requests)) &#123; requests.forEach(scheduler::addRequest); &#125; if (null != result.getItem()) &#123; List&lt;Pipeline&gt; pipelines = response.getRequest().getSpider().getPipelines(); pipelines.forEach(pipeline -&gt; pipeline.process(result.getItem(), response.getRequest())); &#125; &#125; &#125; &#125;&#125; 流转引擎主要分为以下几个步骤： 遍历spider集合，构建request，压入调度器，同时消费爬虫启动事件。 开启一个线程来专门从调取器中获取待处理的request，创建相应的下载器去下载。 消费response,这里分为两步parser和pipeline，解析和处理。 Parser网页解析器，对元数据进行解析，提取我们所需的信息，转换成对应的对象。 public interface Parser&lt;T&gt; &#123; Result&lt;T&gt; parse(Response response); &#125; 实现该方法编写自己的解析逻辑 Pipeline数据处理器，pipeline有管道的意思，解析器完成解析后，把解析的结果扔进数据处理管道中进行处理。是入库，写文件还是打印等等。 public interface Pipeline&lt;T&gt; &#123; void process(T item, Request&lt;?&gt; Request);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"spider","slug":"spider","permalink":"www.google.com/tags/spider/"},{"name":"framework","slug":"framework","permalink":"www.google.com/tags/framework/"}]},{"title":"使用AOP实现日志切入","slug":"LogAspect","date":"2017-12-29T15:24:18.000Z","updated":"2019-07-15T03:27:34.227Z","comments":true,"path":"2017/12/29/LogAspect/","link":"","permalink":"www.google.com/2017/12/29/LogAspect/","excerpt":"在Spring中大量的用到了AOP,比如@Transactional.这里我们写一个简单的Demo,使用AOP实现日志的切入。","text":"在Spring中大量的用到了AOP,比如@Transactional.这里我们写一个简单的Demo,使用AOP实现日志的切入。 定义@Cache注解@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inheritedpublic @interface Cache &#123; int value() default 0;&#125; 定义日志配置类@Configuration@ComponentScan@EnableAspectJAutoProxy(proxyTargetClass = true)public class PeopleConfig &#123;&#125; 定义People接口与Man实现类public interface People &#123; /** * @param name * say hello */ void sayHello(String name);&#125;@Componentpublic class Man implements People &#123; @Override @Cache(1) public void sayHello(String name) &#123; System.out.println(\"Hello, I am Man, My name is : \" + name); &#125;&#125; 定义日志切面类@Component@Aspect@Order(1000)public class LogAspect &#123; //定义切入点,使用Cache注解的方法 @Pointcut(\"@annotation(Cache)\") private void cache()&#123;&#125; //定义环绕通知 @Around(\"cache()\") private Object logAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; Object args = proceedingJoinPoint.getArgs(); System.out.println(\"args:\" + JSONObject.toJSONString(args)); return proceedingJoinPoint.proceed(); &#125; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(PeopleConfig.class); Man man = applicationContext.getBean(\"man\", Man.class); man.sayHello(\"FaderWang\"); &#125;&#125; 测试运行结果args:[\"FaderWang\"]Hello, I am Man, My name is : FaderWang","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"www.google.com/tags/AOP/"}]},{"title":"使用java NIO实现一个echo server","slug":"echo-server","date":"2017-12-19T19:34:13.000Z","updated":"2019-07-15T03:27:34.227Z","comments":true,"path":"2017/12/19/echo-server/","link":"","permalink":"www.google.com/2017/12/19/echo-server/","excerpt":"Java NIO可以让你非阻塞的使用IO，从而可以代替原有的IO API。","text":"Java NIO可以让你非阻塞的使用IO，从而可以代替原有的IO API。 客户端代码public class Client &#123; private Selector selector; private SocketChannel socketChannel; /** * 服务器地址 */ private String hostIp; /** * 监听端口 */ private int listenPort; public Client(String hostIp, int listenPort) throws IOException &#123; this.hostIp = hostIp; this.listenPort = listenPort; initialize(); &#125; private void initialize() throws IOException &#123; //开启监听通道，设置为非阻塞模式 socketChannel = SocketChannel.open(new InetSocketAddress(hostIp, listenPort)); socketChannel.configureBlocking(false); //打开选择器，并注册通道 selector = Selector.open(); socketChannel.register(selector, SelectionKey.OP_READ); ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.submit(() -&gt; &#123; try &#123; while (selector.select() &gt; 0) &#123; Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isReadable()) &#123; SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); channel.read(byteBuffer); byteBuffer.flip(); String receive = Charset.forName(\"UTF-8\").newDecoder().decode(byteBuffer).toString(); System.out.println(\"接收到来自服务器的消息：\" + receive); System.out.println(\"服务器地址：\" + channel.socket().getRemoteSocketAddress()); key.interestOps(SelectionKey.OP_READ); &#125; keyIterator.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; public void sendMsg(String message) throws IOException &#123; ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes(\"UTF-8\")); socketChannel.write(byteBuffer); &#125; public static void main(String[] args) throws IOException &#123; Client client = new Client(\"192.168.5.111\", 1978); client.sendMsg(\"你好NIO, I am FaderWang\"); &#125; 服务端代码public class Server &#123; //缓冲区大小 private static final int BUFFER_SIZE = 1024; //超时时间 private static final int TIME_OUT = 3000; private ServerSocketChannel serverSocketChannel; private Selector selector; /** * 本地监听端口 */ private int listenPort; public Server(int listenPort) throws IOException &#123; this.listenPort = listenPort; initialize(); &#125; public void initialize() throws IOException &#123; //打开监听通道并绑定端口 serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(listenPort)); serverSocketChannel.configureBlocking(false); //开启选择器并注册通道 selector = Selector.open(); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //创建一个处理协议实现类 TCPHandler tcpHandler = new TCPHandlerImpl(BUFFER_SIZE); while (true) &#123; if (selector.select(TIME_OUT) == 0) &#123; System.out.println(\"独自等待\"); continue; &#125; Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); try &#123; if (key.isAcceptable()) &#123; tcpHandler.handleAccept(key); &#125; if (key.isReadable()) &#123; tcpHandler.handleRead(key); &#125; &#125; catch (Exception e) &#123; keyIterator.remove(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; Server server = new Server(1978); &#125; 服务端处理类public interface TCPHandler &#123; /** * 处理接收 * @param key */ void handleAccept(SelectionKey key) throws Exception; /** * 处理写入 * @param key */ void handleWrite(SelectionKey key); /** * 处理读出 * @param key */ void handleRead(SelectionKey key) throws IOException;&#125;public class TCPHandlerImpl implements TCPHandler &#123; private int bufferSize; public TCPHandlerImpl(int bufferSize) &#123; this.bufferSize = bufferSize; &#125; @Override public void handleAccept(SelectionKey key) throws Exception &#123; SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept(); socketChannel.configureBlocking(false); Selector selector = key.selector(); socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)); &#125; @Override public void handleWrite(SelectionKey key) &#123; return; &#125; @Override public void handleRead(SelectionKey key) throws IOException &#123; SocketChannel socketChannel = (SocketChannel) key.channel(); //得到缓冲区 ByteBuffer byteBuffer = (ByteBuffer) key.attachment(); byteBuffer.clear(); if (socketChannel.read(byteBuffer) == -1) &#123; socketChannel.close(); &#125; else &#123; byteBuffer.flip(); String receive = Charset.forName(\"UTF-8\").newDecoder().decode(byteBuffer).toString(); System.out.println(\"接收到来自客户端的消息：\" + receive); System.out.println(\"客户端地址：\" + socketChannel.socket().getRemoteSocketAddress()); String send = \"你好，客户端\" + new Date().toString() + \",已收到你的消息\"; byteBuffer = ByteBuffer.wrap(send.getBytes(\"UTF-8\")); socketChannel.write(byteBuffer); //设置为下一次读取或写入做准备 key.interestOps(SelectionKey.OP_READ); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"NIO","slug":"NIO","permalink":"www.google.com/tags/NIO/"}]}]}