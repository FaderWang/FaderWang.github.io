{"meta":{"title":"Tango","subtitle":"探戈","description":"花有重开日，人无再少年","author":"FaderW","url":"www.google.com"},"pages":[{"title":"about","date":"2018-08-09T18:05:14.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"about/index.html","permalink":"www.google.com/about/index.html","excerpt":"","text":"个人简介 nickname:FaderW industry: Java programmers email: wyx19950516@163.com"},{"title":"分类","date":"2017-07-21T09:00:14.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"categories/index.html","permalink":"www.google.com/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-18T15:25:57.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"friends/index.html","permalink":"www.google.com/friends/index.html","excerpt":"","text":""},{"title":"history","date":"2018-08-09T17:52:54.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"history/index.html","permalink":"www.google.com/history/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-29T15:45:38.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"tags/index.html","permalink":"www.google.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring源码解析之IoC(一)","slug":"spring-ioc","date":"2019-07-11T16:41:50.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"2019/07/11/spring-ioc/","link":"","permalink":"www.google.com/2019/07/11/spring-ioc/","excerpt":"IOC、AOP是Spring的两大核心，通过IOC(依赖注入)，Spring容器为我们管理程序中的java bean，省去了开发人员很多繁琐工作。 BeanFactory和ApplicationContext在Spring IOC容器设计中，分为了两个主要的容器系列，BeanFactory的简单容器系列以及ApplicationContext应用上下文的高级容器系列。而BeanFactory作为所有容器的基类，定义了getBean()等最基本的方法，抽象出容器的概念。","text":"IOC、AOP是Spring的两大核心，通过IOC(依赖注入)，Spring容器为我们管理程序中的java bean，省去了开发人员很多繁琐工作。 BeanFactory和ApplicationContext在Spring IOC容器设计中，分为了两个主要的容器系列，BeanFactory的简单容器系列以及ApplicationContext应用上下文的高级容器系列。而BeanFactory作为所有容器的基类，定义了getBean()等最基本的方法，抽象出容器的概念。 BeanFactory源码： public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = \"&amp;\"; Object getBean(String var1) throws BeansException; &lt;T&gt; T getBean(String var1, Class&lt;T&gt; var2) throws BeansException; ... boolean containsBean(String var1); ... String[] getAliases(String var1);&#125; 容器关系分析Spring中容器的继承关系非常复杂，每个容器的定义与分工非常明确，这里我们先认识一下几个重要的容器 BeanFacotry的一些扩展接口其实这些容器一般可以从它们的名字就能猜出来各自的作用 ListableBeanFactory：可列表的，意思是扩展了容器对bean批量的操作 HierarchicalBeanFactory：层级的，定义了getParentBeanFactory()方法，引入了父子容器的概念 ConfigurableBeanFactory：继承HierarchicalBeanFactory，官方解释是这个扩展接口只是为了允许框架-内部的即插即用，以及对bean工厂配置方法的特殊访问。意思就是主要方便框架内部使用的，稍作了解即可。 ConfigurableListableBeanFactory：继承上面三个直接子接口，主要也是为了内部框架的使用 重要的实现类 AbstractAutowireCapableBeanFactory：该抽象类实现了bean的创建以及属性注入的功能，以及aware接口、InitializingBean等Spring接口功能逻辑的实现 DefaultListableBeanFactory：扩展了上面ConfigurableListableBeanFactory和AbstractAutowireCapableBeanFactory同时提供了最简单的容器实现，从而它也成为了一个最基本的IOC容器。其他IOC容器，比如说XmlBeanFacotry都是在这个简单容器的基础上进行相应的扩展。 以上的容器继承关系的分析有助于我们下面分析容器的启动流程，磨刀不误砍柴工。 IOC容器的初始化正常来说，一个IOC容器的完全启动分两步，容器的初始化以及Bean的初始化。但这并不是绝对，我们可以通过设置bean的lazy-init属性来控制bean的初始化时间，使得bean在容器初始化过程中就进行初始化。这里我们先忽略lazy-init属性，假设两个的初始化是分开的。首先来看IOC容器的初始化过程。 IOC容器的初始化通过调用refresh()，这是IOC容器的核心方法，通过refresh()触发了一系列容器的初始化操作。这里面其实主要干了三件事情：bean资源的定位、beanDefinition的解析和注册。 BeanDefinition是Spring中对bean的一种抽象，其实就是bean在IOC容器中的表现形式。是Spring中定义的一种核心数据结构，依赖注入等功能都是围绕对BeanDefnition的处理来完成的。 BeanDefinition资源定位也就是Resource的定位，它由ResourceLoader通过统一的Resource接口来完成。Spring中已经为我们封装了很多resource，比如ClassPathResource。这里我们不做详解。ClassPathResource resource = new ClassPathResource(\"beans.xml\"); 创建一个类路径下定位xml文件的resource，Spring就会去类路径下寻找BeanDefinition定义的信息，注意这里的resource并不能给DefaultListableBeanFactory直接使用，而是通过BeanDefinitionReader来完成读取。 接着我们以一个常用的实现FileSystemXmlApplicationContext来分析Resource的定位过程。public FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125; &#125;@Overrideprotected Resource getResourceByPath(String path) &#123; if (path != null &amp;&amp; path.startsWith(\"/\")) &#123; path = path.substring(1); &#125; return new FileSystemResource(path);&#125; FileSystemXmlApplicationContext内部的代码很简单，通过构造方法传入的locations设置资源路径，然后调用refresh()方法，启动容器初始化过程。getResourceByPath是一个模板方法，与各个类如何加载xml文件的bean有关，每个类定义自己的资源获取方式，由ResourceLoader在getResource时调用。 refresh()方法的实现在AbstractApplicationContext中 @Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 我们跳到refresh()方法中，这里我们先看第二步obtainFreshBeanFactory()方法，这里是创建容器对象的过程。再跳到obtainFreshBeanFactory()中，具体的过程在refreshBeanFactory()中。protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; refreshBeanFactory(); ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory); &#125; return beanFactory; &#125; refreshBeanFactory()是一个抽象方法，我们看AbstractRefreshableApplicationContext中的实现 @Overrideprotected final void refreshBeanFactory() throws BeansException &#123; if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); &#125;&#125; 我们来看一下refreshBeanFactory()这个方法，主要做了两件事：创建了一个DefaultListableBeanFactory类型的容器，然后以该容器对象为入参调用loadBeanDefinitions(beanFactory)。这个方法也是一个模板方法，由具体的子类实现。因为上面我们是以xml的资源为例，所以我们直接看AbstractXmlApplicationContext中的实现 @Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125;protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125; 方法很简单，创建一个XmlBeanDefinitionReader的对象，初始化相应参数，然后具体的资源获取就委托给该reader对象。 我们进入XmlBeanDefinitionReader的源码中，根据调用链一步步找到我们具体的加载方法，这里是doLoadBeanDefinitions() Document doc = doLoadDocument(inputSource, resource);return registerBeanDefinitions(doc, resource); 这里也是两步，第一步：获取Document的Dom结构对象；第二步，解析Dom对象并注册BeanDefinition。第一步相对比较简单，我们具体来看第二步。 public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 下面其实就是我们的解析步骤了 BeanDefinition的解析首先会创建一个DocumentReader对象，然后具体的register逻辑就委托给该对象。BeanDefinitionDocumentReader是一个接口，这里使用的是Spring的默认实现类DefaultBeanDefinitionDocumentReader @Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125;protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125;protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 具体的逻辑都在DefaultBeanDefinitionDocumentReader对象中。这里讲解一下，主要是递归遍历节点，对不同的标签进行相应的解析，最后是解析&lt;Bean&gt;标签，每个Bean标签对应一个BeanDefinition对象。这里的标签解析同样会委托给一个delegate对象： protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 调用parseBeanDefinitionElement进行解析，得到一个BeanDefinition的包装类对象BeanDefinitionHolder。解析完成后就是保存我们的beanDefintion对象，也就是注册。 BeanDefinition的注册注册是BeanDefinitionReaderUtils.registerBeanDefinition这个调用过程，这里的Registry对象其实就是我们的容器对象，该方法的内部其实还是通过调用Registry的registerBeanDefinition的方法来进行注册的。具体的实现在DefaultListableBeanFacotry中，逻辑很简单，就是讲BeanDefinition保存到Map中，这里就不做详述。 容器初始化成功到这里容器大致就算初始化完成了，严格来说refresh()方法中还进行了很多参数及内部bean的初始化，比如’BeanFactoryPostProcessors’注册及调用, BeanPostProcessors注册等，这里我们先不考虑，只以最简单的容器的bean管理功能来看，这里容器算是初始化完成了。 Bean的初始化不考虑lazy-init=false的情况，bean的初始化是在容器首次调用getBean触发的 getBean()下面我们从DefaultListableBeanFactory的基类AbstractBeanFactory着手去看getBean的实现 protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; final String beanName = transformedBeanName(name); Object bean; // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); &#125; else &#123; logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; registerDependentBean(dep, beanName); getBean(dep); &#125; &#125; // Create bean instance. if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; 我们看到主要逻辑在doGetBean方法中。可以看到该方法比较复杂，这里会进行单例、原型不同类型bean的处理，循环依赖的解决，依赖注入等。因为篇幅问题，这里我们简单看一下流程，而这些具体的过程我会在下一篇文章继续分析。 protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); &#125; return exposedObject;&#125; 首先如果是单例的话，会先从缓存中获取，如果没有的话，最后会调用createBean创建， createBean再调用doCreateBean，这里要注意，该方法是重点，包含了核心逻辑，下一篇我们会具体分析该方法。 创建完成后，首先会检查需不需要注册到容器中，同时return给调用端。Bean的初始化也就完成了。 未完待续……","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"ioc","slug":"ioc","permalink":"www.google.com/tags/ioc/"},{"name":"spring","slug":"spring","permalink":"www.google.com/tags/spring/"}]},{"title":"同步工具类","slug":"同步工具类","date":"2019-01-18T16:32:41.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"2019/01/18/同步工具类/","link":"","permalink":"www.google.com/2019/01/18/同步工具类/","excerpt":"闭锁CountDownLatch 闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。 CountDownLatch是一种灵活的闭锁，它可以始一个或多个线程等待一组事件的发生。CountDownLatch内部包含一个计数器，初始化时传入一个正数，表示当前需要等待的事件数量。每次完成一个事件，调用countDown递减计数器。await方法阻塞到计数器变为0。","text":"闭锁CountDownLatch 闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。 CountDownLatch是一种灵活的闭锁，它可以始一个或多个线程等待一组事件的发生。CountDownLatch内部包含一个计数器，初始化时传入一个正数，表示当前需要等待的事件数量。每次完成一个事件，调用countDown递减计数器。await方法阻塞到计数器变为0。 示例：CountDownLatch countDownLatch = new CountDownLatch(3); for (int i = 0; i &lt; 3; i++) &#123; new Thread(() -&gt; &#123; try &#123; Thread.sleep(10L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"child thread end!\"); countDownLatch.countDown(); &#125;).start(); &#125; countDownLatch.await(); System.out.println(\"main thread end!\"); 创建一个计数器为3的闭锁，主线程等待三个子线程执行完才能结束。 结果：child thread end!child thread end!child thread end!main thread end! 信号量Semaphore 计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。Semaphore中管理着一组虚拟的许可（permit）。许可数量通过构造函数传入。每次执行操作前需要阻塞获取许可，执行完释放许可。可用来实现某种资源池或者对容器施加边界。 示例：利用信号量实现一个简单的阻塞容器public class BoundHashSet&lt;T&gt; &#123; private final Set&lt;T&gt; set; private final Semaphore semaphore; public BoundHashSet(int bound) &#123; this.semaphore = new Semaphore(bound); this.set = Collections.synchronizedSet(new HashSet&lt;&gt;()); &#125; public boolean add(T t) throws InterruptedException &#123; semaphore.acquire(); boolean wasAdd = set.add(t); if (wasAdd) &#123; return true; &#125; else &#123; semaphore.release(); return false; &#125; &#125; public boolean remove(T t) &#123; if (set.remove(t)) &#123; semaphore.release(); return true; &#125; return false; &#125;&#125; 补充一种特殊的的信号量——二值信号量，即许可数量为1。具有不可重入的加锁语义。 栅栏CycleBarrier 栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。线程到达栅栏是调用await方法，这个方法将阻塞到直到所有线程都到达该位置。如果await调用超时，或者调用线程被中断，那么栅栏被认为是打破了，所有调用await的线程将抛出BrokenBarrierException。 初始化栅栏时，同时可传入一个事件，这里是runnable,在成功通过栅栏时会执行它。 示例：public static class Draw implements Runnable&#123; private String value; private CyclicBarrier barrier; public Draw() &#123; &#125; public Draw(CyclicBarrier barrier) &#123; this.barrier = barrier; &#125; public void setBarrier(CyclicBarrier barrier) &#123; this.barrier = barrier; &#125; public String getValue() &#123; return this.value; &#125; @Override public void run() &#123; try &#123; value = RandomStringUtils.randomAlphabetic(4); barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ExecutorService pool = Executors.newFixedThreadPool(8); List&lt;Draw&gt; drawList = Lists.newArrayList(); CyclicBarrier barrier = new CyclicBarrier(4, () -&gt; &#123; StringBuilder stringBuilder = new StringBuilder(); drawList.forEach(draw -&gt; stringBuilder.append(draw.getValue())); System.out.println(stringBuilder.toString()); &#125; ); for (int i = 0; i &lt; 4; i++) &#123; drawList.add(new Draw(barrier)); &#125; drawList.forEach(draw -&gt; pool.submit(draw)); &#125; 分四个线程绘制一个16位的英文串。每个线程分别绘制4位，当四个线程都到达栅栏位置，拼接得到16位的整串。（注意这里的只是使用示例，改程序没有实际意义） 运行结果：iQuNmojnCyUjCPAe","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"concurrent","slug":"concurrent","permalink":"www.google.com/tags/concurrent/"}]},{"title":"post请求流的使用","slug":"post请求流的使用","date":"2018-09-21T14:01:50.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"2018/09/21/post请求流的使用/","link":"","permalink":"www.google.com/2018/09/21/post请求流的使用/","excerpt":"前言在SpringMVC web应用中，对于一个rest接口，获取请求参数我们一般使用@requestParam、@requestBody等注解 。对于表单类型的请求参数，有一下几种获取方式： requestParam注解方式 request.getParameter(String name) request.getInputStream()前两种方式其实是一种方式，@requestParam底层就是利用request.getParameter的原理。这两种方式有一个弊端就是只能一个个获取，而且必须知道对方传过来的参数的key值，如果想要一次性获取，可以使用request.getInputStream方法获取一个inputStream对象，然后读取流里面的数据。","text":"前言在SpringMVC web应用中，对于一个rest接口，获取请求参数我们一般使用@requestParam、@requestBody等注解 。对于表单类型的请求参数，有一下几种获取方式： requestParam注解方式 request.getParameter(String name) request.getInputStream()前两种方式其实是一种方式，@requestParam底层就是利用request.getParameter的原理。这两种方式有一个弊端就是只能一个个获取，而且必须知道对方传过来的参数的key值，如果想要一次性获取，可以使用request.getInputStream方法获取一个inputStream对象，然后读取流里面的数据。 //获取到的数据格式key=value以‘&amp;’分隔的形式age=20&amp;name=faderw 问题但在实际过程中，我们会发现通过request.getInputStream()方式获取的数据为空。 根据Servlet规范，如果同时满足下列条件，则请求体(Entity)中的表单数据，将被填充到request的parameter集合中（request.getParameter系列方法可以读取相关数据） 这是一个HTTP/HTTPS请求 请求方法是POST（querystring无论是否POST都将被设置到parameter中） 请求的类型（Content-Type头）是application/x-www-form-urlencoded Servlet调用了getParameter系列方法 这里的表单数据已经被填充到parameterMap中，不能再通过getInputStream获取。 如何解决这个问题呢。 实现在javax.servlet.http包下面有一个装饰器类HttpServletRequestWrapper，利用这个装饰器类，我们可以重新包装一个HttpServletRequest对象。 public class HttpServletRequestWrapper extends ServletRequestWrapper implements HttpServletRequest &#123; 定义一个装饰器继承HttpServletRequestWrapper,streamBody字节变量用来保存读取的数据，以便于多次读取。 public class InputStreamHttpServletRequestWrapper extends HttpServletRequestWrapper&#123; private final byte[] streamBody; private static final int BUFFER_SIZE = 4096; public InputStreamHttpServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); byte[] bytes = inputStream2Byte(request.getInputStream()); if (bytes.length == 0 &amp;&amp; RequestMethod.POST.name().equals(request.getMethod())) &#123; //从ParameterMap获取参数，并保存以便多次获取 bytes = request.getParameterMap().entrySet().stream() .map(entry -&gt; &#123; String result; String[] value = entry.getValue(); if (value != null &amp;&amp; value.length &gt; 1) &#123; result = Arrays.stream(value).map(s -&gt; entry.getKey() + \"=\" + s) .collect(Collectors.joining(\"&amp;\")); &#125; else &#123; result = entry.getKey() + \"=\" + value[0]; &#125; return result; &#125;).collect(Collectors.joining(\"&amp;\")).getBytes(); &#125; streamBody = bytes; &#125; private byte[] inputStream2Byte(InputStream inputStream) throws IOException &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); byte[] bytes = new byte[BUFFER_SIZE]; int length; while ((length = inputStream.read(bytes, 0, BUFFER_SIZE)) != -1) &#123; outputStream.write(bytes, 0, length); &#125; return outputStream.toByteArray(); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; ByteArrayInputStream inputStream = new ByteArrayInputStream(streamBody); return new ServletInputStream() &#123; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener listener) &#123; &#125; @Override public int read() throws IOException &#123; return inputStream.read(); &#125; &#125;; &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125;&#125; 声明一个带有HttpServletRequest入参的构造器，从该参数对象的流中解析数据，如果没有则继续从parameterMap中获取，然后以key=value&amp;key=value形式拼接。用streamBody接收。然后我们重写getInputStream方法，以后每次调用getInputStream方法，其实是重新利用streamBody重新new一个流，所以可以多次读取。 有了装饰器后，我们就要装饰目标对象。我们都知道SpringMVC的一次请求会被一个个过滤器层层调用，也就是我们常说的责任链模式。利用Filter我们就可以在某个特定的位置装饰HttpServletRequest对象。 public class InputStreamWrapperFilter extends OncePerRequestFilter&#123; @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; ServletRequest servletRequest = new InputStreamHttpServletRequestWrapper(httpServletRequest); filterChain.doFilter(servletRequest, httpServletResponse); &#125;&#125; OncePerRequestFilter这个过滤器能够保证一次请求只经过一次过滤器，所以我们直接继承该类就行了。 @Bean@Order(1)public FilterRegistrationBean inputStreamWrapperFilterRegistration() &#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new InputStreamWrapperFilter()); registrationBean.setName(\"inputStreamWrapperFilter\"); registrationBean.addUrlPatterns(\"/*\"); return registrationBean;&#125; 然后注册该过滤器，设置优先级为1。Spring Boot 会按照order值的大小，从小到大的顺序来依次过滤。 测试我们写一个简单的rest接口测试下 @PostMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)public Object inputStreamTest(HttpServletRequest request) throws Exception &#123; String bs = IOUtils.toString(request.getInputStream(), \"UTF-8\"); Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(1); map.put(\"data\", bs); return map;&#125; curl命令 curl -X POST \\ http://127.0.0.1:9003/home \\ -H 'Cache-Control: no-cache' \\ -H 'Content-Type: application/x-www-form-urlencoded' \\ -H 'Postman-Token: bb6e680c-5142-4d27-b930-6efb118a505a' \\ -d 'age=20&amp;name=wangyuxin' 结果 &#123; \"data\": \"age=20&amp;name=wangyuxin\"&#125;","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"www.google.com/tags/SpringBoot/"}]},{"title":"Venus","slug":"Venus","date":"2018-08-25T21:35:39.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"2018/08/25/Venus/","link":"","permalink":"www.google.com/2018/08/25/Venus/","excerpt":"轻量级爬虫框架Venus核心组件 Downloader(网页下载器) Spider(爬虫处理器) Scheduler(调度器) Parser(网页解析器) Pipline(数据处理器) Engine(流转引擎)","text":"轻量级爬虫框架Venus核心组件 Downloader(网页下载器) Spider(爬虫处理器) Scheduler(调度器) Parser(网页解析器) Pipline(数据处理器) Engine(流转引擎) 具体介绍Downloader网页下载器，顾名思义，就是从网络上下载数据，也就是爬虫的根本事件。给定一个或一组url,进行http请求，获取我们想要的数据（json、html、xml等）。而编写http请求的过程往往是重复的，所以应当进行封装以通用。public class Downloader implements Runnable&#123; private final Scheduler Scheduler; private final Request request; public Downloader(Scheduler scheduler, Request request) &#123; this.Scheduler = scheduler; this.request = request; &#125; @Override public void run() &#123; log.info(\"start request url &#123;&#125;\", request.getUrl()); HttpRequest httpRequest = null; if (\"get\".equalsIgnoreCase(request.getMethod())) &#123; httpRequest = HttpRequest.get(request.getUrl()); &#125; else if (\"post\".equalsIgnoreCase(request.getMethod())) &#123; httpRequest = HttpRequest.post(request.getUrl()); &#125; else &#123; log.error(\"method &#123;&#125; 无效\", request.getMethod()); &#125; InputStream inputStream = httpRequest.contentType(request.contentType()) .headers(request.headers()).connectTimeout(request.getSpider().getConfig().timeout()) .readTimeout(request.getSpider().getConfig().timeout()).stream(); log.info(\"download has finsihed url &#123;&#125;\", request.getUrl()); Response response = new Response(request, inputStream); Scheduler.addResponse(response); &#125;&#125; 一个Downloader就是一个线程,Request对象封装了请求的信息，包括url、header等，请求完后，获取一个包含了返回数据的流，这里不作处理，直接构造一个response对象，然后压入到Scheduler（调取器）的返回队列中去。交给后续的爬虫处理器以及解析器来处理。 Scheduler调取器，就是调度请求与返回的，在解析器与下载器之间进行流转，解析器解析新的url加入请求队列中，调度器再生成新的下载器进行下载。private BlockingQueue&lt;Request&gt; pending = Queues.newLinkedBlockingQueue();private BlockingQueue&lt;Response&gt; processed = Queues.newLinkedBlockingQueue(); Scheduler中有两个队列，待爬取的Request和已爬取的Response。Scheduler提供入队和出队操作，供其他组件进行调用。 Spider爬虫处理器，用于对爬取的数据进行处理，比如说入库、写文件等。public abstract class Spider &#123; protected Config config; protected String name; protected List&lt;String&gt; startUrls = Lists.newArrayList(); protected List&lt;Request&gt; requests = Lists.newArrayList(); protected List&lt;Pipeline&gt; pipelines = Lists.newArrayList(); public void setConfig(Config config) &#123; this.config = config; &#125; public Config getConfig() &#123; return this.config; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public List&lt;Pipeline&gt; getPipelines() &#123; return this.pipelines; &#125; public void setPipelines(List&lt;Pipeline&gt; pipelines) &#123; this.pipelines = pipelines; &#125; public Spider() &#123; &#125; public Spider(String name) &#123; this.name = name; EventManager.registerEvent(EventManager.VenusEvent.SPIDER_STARTED, this::onStart); &#125; public List&lt;String&gt; getStartUrls() &#123; return this.startUrls; &#125; public Spider startUrls(String... urls) &#123; this.startUrls.addAll(Arrays.asList(urls)); return this; &#125; public List&lt;Request&gt; getRequests() &#123; return this.requests; &#125; /** * 爬虫启动前执行 */ public abstract void onStart(Config config); protected &lt;T&gt; Spider addPipline(Pipeline&lt;T&gt; pipeline) &#123; this.pipelines.add(pipeline); return this; &#125; /** * 构建一个request */ public &lt;T&gt; Request&lt;T&gt; makeRequest(String url) &#123; return makeRequest(url, this::parse); &#125; public &lt;T&gt; Request&lt;T&gt; makeRequest(String url, Parser&lt;T&gt; parser) &#123; return new Request&lt;&gt;(this, url, parser); &#125; /** * 解析DOM * 子类需要实现此方法 */ protected abstract &lt;T&gt; Result&lt;T&gt; parse(Response response); protected void resetRequest(Consumer&lt;Request&gt; consumer) &#123; this.resetRequest(this.requests, consumer); &#125; protected void resetRequest(List&lt;Request&gt; requests, Consumer&lt;Request&gt; consumer) &#123; requests.forEach(consumer::accept); &#125;&#125; param-startUrls 抽象类Spider维护了一个url集合，用于接受爬虫原始的url，进一步封装成request对象 method-parse 抽象方法，子类实现该方法定义自己的解析操作 param-pipeline 管道集合，进行数据处理的类，类似管道 Engine整个爬虫流程的核心控制器，流转引擎public class VenusEngine &#123; private List&lt;Spider&gt; spiders; private Config config; private Scheduler scheduler; private ExecutorService executorService; private boolean isRunning; public VenusEngine(Venus venus) &#123; this.spiders = venus.spiders; this.config = venus.config; this.scheduler = new Scheduler(); this.executorService = new ThreadPoolExecutor(config.parallelThreads(), config.parallelThreads(), 60L, TimeUnit.MILLISECONDS, config.queueSize() == 0 ? new SynchronousQueue&lt;&gt;() : (config.queueSize() &lt; 0 ? new LinkedBlockingQueue&lt;&gt;() : new LinkedBlockingQueue&lt;&gt;(config.queueSize())), new ThreadFactoryBuilder().setNameFormat(\"task-thread-%d\").build()); &#125; public void start() &#123; if (isRunning) &#123; throw new RuntimeException(\"Venus 已经启动\"); &#125; isRunning = true; log.info(\"全局启动事件\"); EventManager.fireEvent(VenusEvent.GLOBAL_STARTED, this.config); spiders.forEach(spider -&gt; &#123; // 使用克隆为每个spider对象设置一个config属性 Config config = this.config.clone(); spider.setConfig(config); List&lt;Request&gt; requests = spider.getStartUrls().stream() .map(spider::makeRequest).collect(Collectors.toList()); spider.getRequests().addAll(requests); scheduler.addRequest(requests); EventManager.fireEvent(VenusEvent.SPIDER_STARTED, this.config); &#125;); // 开启一个线程来不断扫描是否有带爬取的Request Thread downloadThread = new Thread(() -&gt; &#123; while (isRunning) &#123; if (!scheduler.hasRequest()) &#123; VenusUtils.sleep(100); continue; &#125; Request request = scheduler.nextRequest(); executorService.submit(new Downloader(scheduler, request)); VenusUtils.sleep(request.getSpider().getConfig().Delay()); &#125; &#125;); downloadThread.setDaemon(true); downloadThread.setName(\"download-thread\"); downloadThread.start(); //消费 this.complete(); &#125; private void complete() &#123; while (isRunning) &#123; if (!scheduler.hasResponse()) &#123; VenusUtils.sleep(100); continue; &#125; Response response = scheduler.nextResponse(); Parser parser = response.getRequest().getParser(); if (null != parser) &#123; Result&lt;?&gt; result = parser.parse(response); List&lt;Request&gt; requests = result.getRequests(); if (!VenusUtils.isEmpty(requests)) &#123; requests.forEach(scheduler::addRequest); &#125; if (null != result.getItem()) &#123; List&lt;Pipeline&gt; pipelines = response.getRequest().getSpider().getPipelines(); pipelines.forEach(pipeline -&gt; pipeline.process(result.getItem(), response.getRequest())); &#125; &#125; &#125; &#125;&#125; 流转引擎主要分为以下几个步骤： 遍历spider集合，构建request，压入调度器，同时消费爬虫启动事件。 开启一个线程来专门从调取器中获取待处理的request，创建相应的下载器去下载。 消费response,这里分为两步parser和pipeline，解析和处理。 Parser网页解析器，对元数据进行解析，提取我们所需的信息，转换成对应的对象。 public interface Parser&lt;T&gt; &#123; Result&lt;T&gt; parse(Response response); &#125; 实现该方法编写自己的解析逻辑 Pipeline数据处理器，pipeline有管道的意思，解析器完成解析后，把解析的结果扔进数据处理管道中进行处理。是入库，写文件还是打印等等。public interface Pipeline&lt;T&gt; &#123; void process(T item, Request&lt;?&gt; Request);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"spider","slug":"spider","permalink":"www.google.com/tags/spider/"},{"name":"framework","slug":"framework","permalink":"www.google.com/tags/framework/"}]},{"title":"使用AOP实现日志切入","slug":"LogAspect","date":"2017-12-29T15:24:18.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"2017/12/29/LogAspect/","link":"","permalink":"www.google.com/2017/12/29/LogAspect/","excerpt":"在Spring中大量的用到了AOP,比如@Transactional.这里我们写一个简单的Demo,使用AOP实现日志的切入。","text":"在Spring中大量的用到了AOP,比如@Transactional.这里我们写一个简单的Demo,使用AOP实现日志的切入。 定义@Cache注解@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inheritedpublic @interface Cache &#123; int value() default 0;&#125; 定义日志配置类@Configuration@ComponentScan@EnableAspectJAutoProxy(proxyTargetClass = true)public class PeopleConfig &#123;&#125; 定义People接口与Man实现类public interface People &#123; /** * @param name * say hello */ void sayHello(String name);&#125;@Componentpublic class Man implements People &#123; @Override @Cache(1) public void sayHello(String name) &#123; System.out.println(\"Hello, I am Man, My name is : \" + name); &#125;&#125; 定义日志切面类@Component@Aspect@Order(1000)public class LogAspect &#123; //定义切入点,使用Cache注解的方法 @Pointcut(\"@annotation(Cache)\") private void cache()&#123;&#125; //定义环绕通知 @Around(\"cache()\") private Object logAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; Object args = proceedingJoinPoint.getArgs(); System.out.println(\"args:\" + JSONObject.toJSONString(args)); return proceedingJoinPoint.proceed(); &#125; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(PeopleConfig.class); Man man = applicationContext.getBean(\"man\", Man.class); man.sayHello(\"FaderWang\"); &#125;&#125; 测试运行结果args:[&quot;FaderWang&quot;]Hello, I am Man, My name is : FaderWang","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"www.google.com/tags/AOP/"}]},{"title":"使用java NIO实现一个echo server","slug":"echo-server","date":"2017-12-19T19:34:13.000Z","updated":"2019-07-19T01:51:25.778Z","comments":true,"path":"2017/12/19/echo-server/","link":"","permalink":"www.google.com/2017/12/19/echo-server/","excerpt":"Java NIO可以让你非阻塞的使用IO，从而可以代替原有的IO API。","text":"Java NIO可以让你非阻塞的使用IO，从而可以代替原有的IO API。 客户端代码public class Client &#123; private Selector selector; private SocketChannel socketChannel; /** * 服务器地址 */ private String hostIp; /** * 监听端口 */ private int listenPort; public Client(String hostIp, int listenPort) throws IOException &#123; this.hostIp = hostIp; this.listenPort = listenPort; initialize(); &#125; private void initialize() throws IOException &#123; //开启监听通道，设置为非阻塞模式 socketChannel = SocketChannel.open(new InetSocketAddress(hostIp, listenPort)); socketChannel.configureBlocking(false); //打开选择器，并注册通道 selector = Selector.open(); socketChannel.register(selector, SelectionKey.OP_READ); ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.submit(() -&gt; &#123; try &#123; while (selector.select() &gt; 0) &#123; Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isReadable()) &#123; SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); channel.read(byteBuffer); byteBuffer.flip(); String receive = Charset.forName(\"UTF-8\").newDecoder().decode(byteBuffer).toString(); System.out.println(\"接收到来自服务器的消息：\" + receive); System.out.println(\"服务器地址：\" + channel.socket().getRemoteSocketAddress()); key.interestOps(SelectionKey.OP_READ); &#125; keyIterator.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; public void sendMsg(String message) throws IOException &#123; ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes(\"UTF-8\")); socketChannel.write(byteBuffer); &#125; public static void main(String[] args) throws IOException &#123; Client client = new Client(\"192.168.5.111\", 1978); client.sendMsg(\"你好NIO, I am FaderWang\"); &#125; 服务端代码public class Server &#123; //缓冲区大小 private static final int BUFFER_SIZE = 1024; //超时时间 private static final int TIME_OUT = 3000; private ServerSocketChannel serverSocketChannel; private Selector selector; /** * 本地监听端口 */ private int listenPort; public Server(int listenPort) throws IOException &#123; this.listenPort = listenPort; initialize(); &#125; public void initialize() throws IOException &#123; //打开监听通道并绑定端口 serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(listenPort)); serverSocketChannel.configureBlocking(false); //开启选择器并注册通道 selector = Selector.open(); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //创建一个处理协议实现类 TCPHandler tcpHandler = new TCPHandlerImpl(BUFFER_SIZE); while (true) &#123; if (selector.select(TIME_OUT) == 0) &#123; System.out.println(\"独自等待\"); continue; &#125; Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); try &#123; if (key.isAcceptable()) &#123; tcpHandler.handleAccept(key); &#125; if (key.isReadable()) &#123; tcpHandler.handleRead(key); &#125; &#125; catch (Exception e) &#123; keyIterator.remove(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; Server server = new Server(1978); &#125; 服务端处理类public interface TCPHandler &#123; /** * 处理接收 * @param key */ void handleAccept(SelectionKey key) throws Exception; /** * 处理写入 * @param key */ void handleWrite(SelectionKey key); /** * 处理读出 * @param key */ void handleRead(SelectionKey key) throws IOException;&#125;public class TCPHandlerImpl implements TCPHandler &#123; private int bufferSize; public TCPHandlerImpl(int bufferSize) &#123; this.bufferSize = bufferSize; &#125; @Override public void handleAccept(SelectionKey key) throws Exception &#123; SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept(); socketChannel.configureBlocking(false); Selector selector = key.selector(); socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)); &#125; @Override public void handleWrite(SelectionKey key) &#123; return; &#125; @Override public void handleRead(SelectionKey key) throws IOException &#123; SocketChannel socketChannel = (SocketChannel) key.channel(); //得到缓冲区 ByteBuffer byteBuffer = (ByteBuffer) key.attachment(); byteBuffer.clear(); if (socketChannel.read(byteBuffer) == -1) &#123; socketChannel.close(); &#125; else &#123; byteBuffer.flip(); String receive = Charset.forName(\"UTF-8\").newDecoder().decode(byteBuffer).toString(); System.out.println(\"接收到来自客户端的消息：\" + receive); System.out.println(\"客户端地址：\" + socketChannel.socket().getRemoteSocketAddress()); String send = \"你好，客户端\" + new Date().toString() + \",已收到你的消息\"; byteBuffer = ByteBuffer.wrap(send.getBytes(\"UTF-8\")); socketChannel.write(byteBuffer); //设置为下一次读取或写入做准备 key.interestOps(SelectionKey.OP_READ); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"www.google.com/categories/Java/"}],"tags":[{"name":"NIO","slug":"NIO","permalink":"www.google.com/tags/NIO/"}]}]}