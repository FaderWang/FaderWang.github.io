{"meta":{"title":"tango","subtitle":null,"description":"最不稀罕的东西：不在乎人的赞美，不喜欢人的殷勤，还有你无差别对待的好","author":"FaderWang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-08-09T18:05:14.000Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人简介 nickname:FaderW industry: Java programmers email: wyx19950516@163.com"},{"title":"分类","date":"2017-07-21T09:00:14.000Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"history","date":"2018-08-09T17:52:54.000Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"history/index.html","permalink":"http://yoursite.com/history/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-29T15:45:38.000Z","updated":"2018-08-09T11:43:29.123Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-08-09T11:43:29.107Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"2018/08/09/hello-world/","link":"","permalink":"http://yoursite.com/2018/08/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"使用AOP实现日志切入","slug":"LogAspect","date":"2017-12-29T15:24:18.000Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"2017/12/29/LogAspect/","link":"","permalink":"http://yoursite.com/2017/12/29/LogAspect/","excerpt":"","text":"如果想要在方法的某个地方输出日志，但是不想要改变原有的代码。这时候可以使用代理、或者切面（原理都是AOP），这里我们使用Aspect切面来实现日志输出。 定义Cache注解1234567@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inheritedpublic @interface Cache &#123; int value() default 0;&#125; 定义日志配置类12345@Configuration@ComponentScan@EnableAspectJAutoProxy(proxyTargetClass = true)public class PeopleConfig &#123;&#125; 定义People接口与Man实现类123456789101112131415161718public interface People &#123; /** * @param name * say hello */ void sayHello(String name);&#125;@Componentpublic class Man implements People &#123; @Override @Cache(1) public void sayHello(String name) &#123; System.out.println(\"Hello, I am Man, My name is : \" + name); &#125;&#125; 定义日志切面类1234567891011121314151617181920212223@Component@Aspect@Order(1000)public class LogAspect &#123; //定义切入点,使用Cache注解的方法 @Pointcut(\"@annotation(Cache)\") private void cache()&#123;&#125; //定义环绕通知 @Around(\"cache()\") private Object logAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; Object args = proceedingJoinPoint.getArgs(); System.out.println(\"args:\" + JSONObject.toJSONString(args)); return proceedingJoinPoint.proceed(); &#125; public static void main(String[] args) &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(PeopleConfig.class); Man man = applicationContext.getBean(\"man\", Man.class); man.sayHello(\"FaderWang\"); &#125;&#125; 测试运行结果12args:[\"FaderWang\"]Hello, I am Man, My name is : FaderWang","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"}]},{"title":"使用java NIO实现一个echo server","slug":"echo-server","date":"2017-12-19T19:34:13.000Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"2017/12/19/echo-server/","link":"","permalink":"http://yoursite.com/2017/12/19/echo-server/","excerpt":"","text":"使用Java NIO来实现一个简单的echo server服务器，废话不多说，直接上代码 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Client &#123; private Selector selector; private SocketChannel socketChannel; /** * 服务器地址 */ private String hostIp; /** * 监听端口 */ private int listenPort; public Client(String hostIp, int listenPort) throws IOException &#123; this.hostIp = hostIp; this.listenPort = listenPort; initialize(); &#125; private void initialize() throws IOException &#123; //开启监听通道，设置为非阻塞模式 socketChannel = SocketChannel.open(new InetSocketAddress(hostIp, listenPort)); socketChannel.configureBlocking(false); //打开选择器，并注册通道 selector = Selector.open(); socketChannel.register(selector, SelectionKey.OP_READ); ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.submit(() -&gt; &#123; try &#123; while (selector.select() &gt; 0) &#123; Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isReadable()) &#123; SocketChannel channel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); channel.read(byteBuffer); byteBuffer.flip(); String receive = Charset.forName(\"UTF-8\").newDecoder().decode(byteBuffer).toString(); System.out.println(\"接收到来自服务器的消息：\" + receive); System.out.println(\"服务器地址：\" + channel.socket().getRemoteSocketAddress()); key.interestOps(SelectionKey.OP_READ); &#125; keyIterator.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; public void sendMsg(String message) throws IOException &#123; ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes(\"UTF-8\")); socketChannel.write(byteBuffer); &#125; public static void main(String[] args) throws IOException &#123; Client client = new Client(\"192.168.5.111\", 1978); client.sendMsg(\"你好NIO, I am FaderWang\"); &#125; 服务端代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Server &#123; //缓冲区大小 private static final int BUFFER_SIZE = 1024; //超时时间 private static final int TIME_OUT = 3000; private ServerSocketChannel serverSocketChannel; private Selector selector; /** * 本地监听端口 */ private int listenPort; public Server(int listenPort) throws IOException &#123; this.listenPort = listenPort; initialize(); &#125; public void initialize() throws IOException &#123; //打开监听通道并绑定端口 serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(listenPort)); serverSocketChannel.configureBlocking(false); //开启选择器并注册通道 selector = Selector.open(); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //创建一个处理协议实现类 TCPHandler tcpHandler = new TCPHandlerImpl(BUFFER_SIZE); while (true) &#123; if (selector.select(TIME_OUT) == 0) &#123; System.out.println(\"独自等待\"); continue; &#125; Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); try &#123; if (key.isAcceptable()) &#123; tcpHandler.handleAccept(key); &#125; if (key.isReadable()) &#123; tcpHandler.handleRead(key); &#125; &#125; catch (Exception e) &#123; keyIterator.remove(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; Server server = new Server(1978); &#125; 服务端处理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface TCPHandler &#123; /** * 处理接收 * @param key */ void handleAccept(SelectionKey key) throws Exception; /** * 处理写入 * @param key */ void handleWrite(SelectionKey key); /** * 处理读出 * @param key */ void handleRead(SelectionKey key) throws IOException;&#125;public class TCPHandlerImpl implements TCPHandler &#123; private int bufferSize; public TCPHandlerImpl(int bufferSize) &#123; this.bufferSize = bufferSize; &#125; @Override public void handleAccept(SelectionKey key) throws Exception &#123; SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept(); socketChannel.configureBlocking(false); Selector selector = key.selector(); socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize)); &#125; @Override public void handleWrite(SelectionKey key) &#123; return; &#125; @Override public void handleRead(SelectionKey key) throws IOException &#123; SocketChannel socketChannel = (SocketChannel) key.channel(); //得到缓冲区 ByteBuffer byteBuffer = (ByteBuffer) key.attachment(); byteBuffer.clear(); if (socketChannel.read(byteBuffer) == -1) &#123; socketChannel.close(); &#125; else &#123; byteBuffer.flip(); String receive = Charset.forName(\"UTF-8\").newDecoder().decode(byteBuffer).toString(); System.out.println(\"接收到来自客户端的消息：\" + receive); System.out.println(\"客户端地址：\" + socketChannel.socket().getRemoteSocketAddress()); String send = \"你好，客户端\" + new Date().toString() + \",已收到你的消息\"; byteBuffer = ByteBuffer.wrap(send.getBytes(\"UTF-8\")); socketChannel.write(byteBuffer); //设置为下一次读取或写入做准备 key.interestOps(SelectionKey.OP_READ); &#125; &#125;&#125;","categories":[{"name":"IO","slug":"IO","permalink":"http://yoursite.com/categories/IO/"}],"tags":[{"name":"echo server","slug":"echo-server","permalink":"http://yoursite.com/tags/echo-server/"}]},{"title":"Apache Commons类库","slug":"Apache-Common-Study","date":"2017-07-20T19:39:41.000Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"2017/07/20/Apache-Common-Study/","link":"","permalink":"http://yoursite.com/2017/07/20/Apache-Common-Study/","excerpt":"","text":"Apache common提供了很多强大的工具集，简化了Java开发人员的开发。下面是我个人一些使用心得。 \b介绍下commons-lang3 jar类库下的一些常用工具集RandomStringUtils 生成随机串 123456789101112//生成随机指定长度的字符串RandomStringUtils.random(4);//生成指定字符指定长度的字符串RandomStringUtils.random(4,new char[]&#123;'a', 'b', 'c', 'd'&#125;);//生成指定长度的数字字符串RandomStringUtils.randomNumeric(4);//生成自定长度的Alpha字母串（a-z,A-Z）RandomStringUtils.randomAlphabetic(4);//生成指定长度的Alpha字母或数字串（a-z,A-z,0-9）RandomStringUtils.randomAlphanumeric(4);//获取指定长度的Ascii值在（32-126）的字符串RandomStringUtils.randomAscii(4); StringUtils 非空判断 12345678//判断是否为null或\"\"StringUtils.isNotEmpty(\"\");//判断是否为null或者\"\"(去空格)StringUtils.isNotBlank(\" \");//将null或\" \"转换为\"\"(空串)StringUtils.trimToEmpty(\" \");//将null或\"\"转换为nullStringUtils.trimToNull(\"\"); StringUtils分装的方法很多，这里就不一一列举，有兴趣可以查看文档","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Apache Commons","slug":"Apache-Commons","permalink":"http://yoursite.com/tags/Apache-Commons/"}]},{"title":"使用Appveyor自动部署Hexo","slug":"Auto-Deploy-Hexo","date":"2017-07-20T17:15:13.000Z","updated":"2018-08-09T11:43:29.107Z","comments":true,"path":"2017/07/20/Auto-Deploy-Hexo/","link":"","permalink":"http://yoursite.com/2017/07/20/Auto-Deploy-Hexo/","excerpt":"","text":"","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"Appveyor","slug":"Appveyor","permalink":"http://yoursite.com/tags/Appveyor/"}]}]}